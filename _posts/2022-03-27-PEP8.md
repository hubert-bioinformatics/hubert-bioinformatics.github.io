---
layout: post
title: Style guide for Python code - PEP8
date: 2022-03-27 12:15:00 +0900
published: true
categories: [Programming, Python]
tags: [python]
img_path: /assets/img/post/
---

## Python Language
***
 > <br>생각이나 느낌을 나타내거나 전달하기 위하여 사용하는<br> 음성, 문자, 몸짓 등의 수단 또는 그 사회관습적 체계<br><br>

 언어의 사전적 정의입니다. 언어란 한 사회의 구성원 사이에 약속된 의사소통 규칙이자 오랜 세월 특유의 문화와 역사가 담긴 사회관습적 체계입니다.

 여러분은 외국어를 공부한 경험이 있을 것입니다. 처음에 어떤 방식으로 접근하셨나요? 누군가는 단어와 문법을 공부하며 언어에 대한 지식을 쌓아갑니다. 누군가는 외국에서 현지인들과 소통하며 자연스럽게 외국어를 익힙니다. 어떤 방식을 사용하던지 최종 목표는 그 언어에 담긴 철학을 이해하고 자유롭게 구사하여 의사 소통 하는 것입니다.

 Programming language도 마찬가지입니다. Python을 사용해서 code를 작성하고 다른 개발자와 의사 소통 하려면 우선 python을 이해해야 합니다.<br><br>


## Python Philosophy
***
 > <br>Readability counts.<br><br>

 Python의 철학은 [PEP20: The Zen of Python](https://peps.python.org/pep-0020/, "PEP20: The Zen of Python")에서 19개 문장으로 설명합니다. 한 마디로 요약하면 readability! Python은 누가 봐도 읽기 쉽고 간결한 code를 지향합니다.<br><br>


## PEP8은 무엇일까요?
***
 PEP(*P*ython *E*nhancement *P*roposals)는 'Python 제안 사항' 정도로 이해할 수 있습니다. Python의 새로운 기능이나 적용사항을 안내하고 사용 가이드라인과 정보를 제공합니다.

 PEP8은 python을 만든 Guido van Rossum을 포함하여 세 명의 저자가 작성한 문서로 python code에 대한 style guide 내용을 담고 있습니다. 일종의 code 규칙을 제안하는 문서로 이해할 수 있습니다. 이 외에도 다양한 python style guide가 존재하는데 대부분 PEP8을 기반으로 만들어졌기 때문에 알아두는 것이 좋습니다. 상세한 내용은 [PEP8 공식문서](https://peps.python.org/pep-0008/, "PEP8 공식문서")를 참고하세요. 이제부터 PEP8을 하나씩 알아보겠습니다.<br><br>


## A Foolish Consistency is the Hobgoblin of Little Minds
***
 미국의 철학자이자 시인으로 활동한 Ralph Waldo Emerson의 'Self-Reliance'에 나오는 문구입니다. 원문은 아래와 같습니다.

 > <br>"A *foolish consistency* is the hobgoblin of little mindes, <br>adored by little statesment and philosophers and divines."<br><br><br>
 "*어리석은 일관성*은 별 볼 일 없는 정치가와 철학자, 그리고 신학자들이 사랑하는, <br>편협한 마음을 가진 홉고블린이다."<br><br>

 문구의 앞/뒤 문맥을 살펴보면 오늘과 내일 하는 말이 모순될 지언정, 다른 사람의 시선에 휘둘리지 않고 자신을 신뢰하는 자세가 사회를 지탱하고 더 나은 방향으로 나아가도록 만든다고 이야기 합니다. 사회의 정해진 규칙과 타인이 옳다고 여기는 기준에 맞춰 바보같이 사는 것은 소인배 홉고블린에 지나지 않다는 의미이기도 합니다. 이 사상은 오늘날 미국을 지탱하는 개인주의 정신의 근간이 되었습니다.

 Python code에서 가독성은 매우 중요합니다. 따라서 PEP8이 제시하는 style guide에 얽매일 필요없이 더 나은 방식이 있다면 반드시 사용하시기 바랍니다.<br><br>


## Code Lay-out
***
## &nbsp;&nbsp;&nbsp;&nbsp;Indentation
***
 하나의 indentation 레벨은 4개의 spaces를 사용합니다. 연속된 line은 괄호/중괄호/대괄호 내부에서 python의 implicit line joining을 사용하여 수직선 상에 맞추거나 hanging indent를 사용합니다. 이 때 첫 번째 line에 arguments를 넣지 않습니다. 또한 2-spaces로 대체함으로써 예외적으로 4-spaces 규칙을 벗어날 수 있습니다.

```python
## Correct:

# Aligned with opening delimiter.
foo = long_function_name(var_one, var_two,
                        var_three, var_foue)

 # Add 4-spaces (an extra level of indentation) to distinguish arguments from the rest.
def long_function_name(
        var_one, var_two, var_three, 
        var_four):
    print(var_one)

# Hanging indents should add a level.
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)


## Wrong:

# Arguments on first line forbidden when not using vertical alignment.
foo = long_function_name(var_one, var_two,
var_three, var_four)

# Further indentation required as indentation is not distinguishable.
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)
```

 if문 같은 조건문의 조건이 길어지는 경우, 괄호를 사용하여 multiline으로 작성합니다. 마찬가지로 4-spaces 규칙이 기본 적용되며 경우에 따라 추가 indent를 사용합니다.

 ```python
# No extra indentation.
if (this_is_one_thing and
    that_is_another_thing):
    do_something()

# Add a comment, which will provide some distinction in editors
# supporting syntax highlighting.
if (this_is_one_thing and
    that_is_another_thing):
    # Since both conditions are true, we can frobnicate.
    do_something()

# Add some extra indentation on the conditional continuation line.
if (this_is_one_thing
        and that_is_another_thing):
    do_something()
```

 닫는 괄호/중괄호/대괄호는 multiline 중 마지막 line의 첫 번째 글자와 동일선상에 맞추거나, 첫 번째 line의 시작과 동일선상에 맞춥니다.

```python
# Closing brace/bracker/parenthesis on multiline constructs
# line up under the first non-whitespace character of the last line of list
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
    )
 
# or line up under the first character of the line that starts the multiline construct
my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
)
```
<br><br>


## &nbsp;&nbsp;&nbsp;&nbsp;Tabs or Spaces?
***
 Space가 더 선호되는 방식입니다. Tab은 이미 작성된 code에서 indent가 tab으로 작성되어 있는 경우 사용합니다. Python3에서는 space와 tab 혼용을 금지합니다. Python2에서는 혼용이 가능하지만 tab을 space로 변환하도록 강력히 권고합니다.<br><br>


## &nbsp;&nbsp;&nbsp;&nbsp;Maximum Line Length
***
 모든 line은 최대 79자 이내로 제한합니다. Docstrings나 comments 같은 몇몇 구조는 최대 72자로 제한합니다. Line의 글자수를 제한하면 두 개 이상 code를 editor로 열어서 동시에 작업할 수 있습니다. 또한 더 깔끔한 code를 작성할 수 있습니다. Multiline으로 작성할 경우 앞서 언급한 indent 규칙을 준수하고 backslash를 사용합니다.

```python
with open('/path/to/some/file/you/want/to/read') as file_1, \
    open('/path/to/some/file/being/written') as file_2:
    file_2.write(file_1.read())
```
<br><br>


## &nbsp;&nbsp;&nbsp;&nbsp;Should a Line Break Before or Agter a Binary Operator?
***
 사칙연산 기호와 line break의 위치에 관한 내용입니다. 과거에는 사칙연산 기호 이후에 line break가 위치하는 style을 권장했습니다. 하지만 다음 두 가지 이유로 가독성을 떨어뜨립니다.

 1. 연산기호가 line마다 다른 위치로 흩어집니다.
 2. 연산기호의 대상을 명확하게 파악하기 어렵습니다.

```python
## Wrong:

# operators sit far away from their operands

income = (gross_wages +
        taxable_interest +
        (dividents - qualified_dividents) -
        ira_deduction -
        student_loan_interest)
```

 하지만 수학에서는 전통적으로 사칙연산 기호 이전에 line break가 위치하는 style을 사용합니다. 가독성이 더 좋은 이 방식을 python에서도 권장합니다.

```python
## Correct:

# easy to match operators with operands

income = (gross_wages
        + taxable_interest 
        + (dividents - qualified_dividents)
        - ira_deduction
        - student_loan_interest)
```
<br><br>


## &nbsp;&nbsp;&nbsp;&nbsp;Blank Lines
***
 사